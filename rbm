#!/usr/bin/env bash

show_help() {
	cat <<-'EOF'
		Usage: rbm [-o <newbase>] [-u <upstream>]
		For all branches run  git rebase <upstream> <branch> [--onto <newbase>]
		Use master for upstream if non is provided.
EOF
}

newbase=""
upstream="master"

while getopts ":ho:u:" opt; do
	case "$opt" in
		h)
			show_help
			exit 0
			;;
		o) newbase=$OPTARG
			;;
		u) upstream=$OPTARG
			;;
		\?)
			echo "Invalid option: -$OPTARG" >&2
			exit 1
			;;
		:)
			echo "Option -$OPTARG requires an argument." >&2
			exit 1
			;;
	esac
done
shift "$((OPTIND-1))"

orig_branch="$(git rev-parse --abbrev-ref @)"
[ "$orig_branch" = HEAD ] && orig_branch="$(git rev-parse @)"

# Check for unstaged changes
# TODO: Check only for unstaged changes not uncommitted
if [ -n "$(git status --porcelain -uno)" ]; then
	echo "Commit or stash changes before rebase."
	exit 1
fi

branches=$(git branch | sed -e 's/[*]//' -e '/master/d' -e '/(no branch, rebasing/d' -e '/(detached from /d' -e "/${upstream}/d" -e "/${newbase}/d")

for branch in $branches; do
	echo -n "Rebasing $branch "
	args=( rebase "$upstream" "$branch" )
	[ -n "$newbase" ] && args+=( --onto "$newbase" )
	if git "${args[@]}" 1>/dev/null 2>&1; then
		tput setaf 2 0 0
		echo "(ok)"
		tput sgr0
	else
		git rebase --abort
		tput setaf 1 0 0
		echo "(failed)"
		tput sgr0
		failed_branches=("${failed_branches[@]}" "$branch")
	fi
done

if [ ${#failed_branches[@]} -eq 0 ]; then
	git checkout "$orig_branch"
elif [ ${#failed_branches[@]} -eq 1 ]; then
	# If only one branch failed to rebase, offer to rebase interactively
	read -p "Rebase ${failed_branches[0]} interactively? [y/N] " resp
	if [ -z "$resp" ]; then
		resp=n
	fi
	case "$resp" in
		Y*|y*)
			git rebase -i master "${failed_branches[0]}"
			;;
		N*|n*)
			git checkout "$orig_branch"
			;;
	esac
else
	# TODO: Select repo to rebase
	echo "${failed_branches[@]}"
	git checkout "$orig_branch"
fi
